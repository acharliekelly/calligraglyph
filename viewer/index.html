<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>CalligraGlyph Viewer (Simple)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root { --b:#111; --muted:#6b7280; --line:#e5e7eb; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; color:#111; }
    .wrap { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    @media (max-width: 1100px) { .wrap { grid-template-columns: 1fr; } }
    .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 12px; background: #fff; }
    #stage { width: 100%; display: flex; align-items: center; justify-content: center; border: 1px dashed var(--line); border-radius: 12px; aspect-ratio: 1/1; background: #fff; }
    svg { width: 100%; height: 100%; }
    textarea { width: 100%; height: 320px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; }
    .controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-top: 8px; }
    button, input[type="number"] {
      padding: 8px 12px; border-radius: 8px; border: 1px solid #d1d5db; background: #fafafa; cursor: pointer;
    }
    button:disabled { opacity: .5; cursor: default; }
    .meta { color: var(--muted); font-size: 12px; margin-left: 8px; }
    .badge { background: #eef2ff; color: #3730a3; border-radius: 999px; padding: 2px 8px; font-size: 12px; display: inline-block; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  </style>
</head>
<body>
  <h1>Kaligraf Glyph Viewer</h1>
  <p class="badge">Paste JSON from the CLI → Apply → Play</p>

  <div class="wrap">
    <div class="card">
      <div class="row" style="margin-bottom:8px;">
        <input type="file" id="file" accept=".json" />
        <button id="loadSample">Load Sample</button>
        <button id="apply">Apply JSON</button>
        <label>Speed × <input type="number" id="speed" value="1.0" min="0.25" max="4" step="0.05" style="width:70px"/></label>
      </div>
      <textarea id="json" placeholder="Paste glyph JSON here..."></textarea>
    </div>

    <div class="card">
      <div id="stage"><em>Load JSON to preview</em></div>
      <div class="controls">
        <button id="play" disabled>Play</button>
        <button id="pause" disabled>Pause</button>
        <button id="reset" disabled>Reset</button>
        <button id="step" disabled>Step</button>
        <span class="meta" id="meta"></span>
      </div>
    </div>
  </div>

  <!-- React via CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>

  <script>
    const { useRef, useEffect, useState, useMemo } = React;

    function GlyphPlayer({ glyph, speed = 1.0, paused, stepSignal }) {
      const groupRef = useRef(null);
      const [ready, setReady] = useState(false);

      const sortedStrokes = useMemo(
        () => [...glyph.strokes].sort((a,b)=>a.order-b.order),
        [glyph]
      );

      // Prepare dash arrays when paths mount
      useEffect(() => {
        const g = groupRef.current;
        if (!g) return;
        const els = Array.from(g.querySelectorAll("path"));
        els.forEach(el => {
          try {
            const L = el.getTotalLength();
            el.style.strokeDasharray = `${L}`;
            el.style.strokeDashoffset = `${L}`;
            el.style.transition = "none";
          } catch { /* ignore */ }
        });
        setReady(true);
      }, [glyph]);

      // Reset helper
      const resetAll = () => {
        const g = groupRef.current;
        if (!g) return;
        const els = Array.from(g.querySelectorAll("path"));
        els.forEach(el => {
          try {
            const L = el.getTotalLength();
            el.style.transition = "none";
            el.style.strokeDashoffset = `${L}`;
          } catch {}
        });
      };

      // Imperative play sequence
      useEffect(() => {
        if (!ready) return;
        if (paused) return;

        let cancelled = false;
        const g = groupRef.current;

        const playStroke = (i) => {
          if (cancelled || i >= sortedStrokes.length) return;
          const s = sortedStrokes[i];
          const el = g.querySelector(`#${CSS.escape(s.id)}`);
          if (!el) { playStroke(i+1); return; }

          const L = el.getTotalLength?.() ?? 0;
          const dur = (s.durationMs || 400) / speed;
          const delay = (s.delayMs || 0) / speed;

          // reset current path
          el.style.transition = "none";
          el.style.strokeDashoffset = `${L}`;
          void el.getBoundingClientRect(); // reflow

          // animate
          el.style.transition = `stroke-dashoffset ${dur}ms linear`;
          el.style.strokeDashoffset = "0";

          setTimeout(() => { if (!cancelled) playStroke(i+1); }, dur + delay);
        };

        // Start fresh each play
        resetAll();
        playStroke(0);
        return () => { cancelled = true; };
      }, [paused, speed, ready, sortedStrokes]);

      // Step one stroke at a time
      useEffect(() => {
        if (!ready || stepSignal <= 0) return;
        const i = stepSignal - 1; // external sends 1..N
        if (i >= sortedStrokes.length) return;
        const g = groupRef.current;
        const s = sortedStrokes[i];
        const el = g.querySelector(`#${CSS.escape(s.id)}`);
        if (!el) return;

        const L = el.getTotalLength?.() ?? 0;
        const dur = (s.durationMs || 400) / speed;

        el.style.transition = "none";
        el.style.strokeDashoffset = `${L}`;
        void el.getBoundingClientRect();
        el.style.transition = `stroke-dashoffset ${dur}ms linear`;
        el.style.strokeDashoffset = "0";
      }, [stepSignal, ready, speed, sortedStrokes]);

      const vb = `0 0 ${glyph.bbox.w} ${glyph.bbox.h}`;
      const strokeWidth = 28; // you can compute from glyph.nib later

      return (
        React.createElement('svg', { viewBox: vb, xmlns: "http://www.w3.org/2000/svg" },
          React.createElement('g', { ref: groupRef, fill: "none", stroke: "#111", strokeWidth, strokeLinecap:"round", strokeLinejoin:"round" },
            sortedStrokes.map(s => React.createElement('path', { id: s.id, key: s.id, d: s.path }))
          )
        )
      );
    }

    function AppRoot() {
      const [glyph, setGlyph] = useState(null);
      const [paused, setPaused] = useState(true);
      const [speed, setSpeed] = useState(1.0);
      const [stepCount, setStepCount] = useState(0);

      useEffect(() => {
        const file = document.getElementById("file");
        const apply = document.getElementById("apply");
        const loadSample = document.getElementById("loadSample");
        const speedInp = document.getElementById("speed");
        const playBtn = document.getElementById("play");
        const pauseBtn = document.getElementById("pause");
        const resetBtn = document.getElementById("reset");
        const stepBtn = document.getElementById("step");
        const jsonTA = document.getElementById("json");
        const meta = document.getElementById("meta");

        function updateButtons() {
          const enabled = !!glyph;
          playBtn.disabled = !(enabled && paused);
          pauseBtn.disabled = !(enabled && !paused);
          resetBtn.disabled = !enabled;
          stepBtn.disabled = !enabled;
          meta.textContent = glyph ? `${glyph.style} • ${glyph.case} ${glyph.char} • ${glyph.strokes.length} strokes` : '';
        }
        updateButtons();

        async function onFile(e) {
          const f = e.target.files?.[0];
          if (!f) return;
          const txt = await f.text();
          jsonTA.value = txt;
          applyJson();
        }
        function applyJson() {
          try {
            const j = JSON.parse(jsonTA.value);
            if (!j?.strokes?.length || !j?.bbox) throw new Error("Missing strokes/bbox");
            setGlyph(j);
            setPaused(true);
            setStepCount(0);
          } catch (err) {
            alert("Invalid JSON: " + err.message);
          }
        }
        function loadSampleJson() {
          const sample = {
            "schema":"kaligraf/v1","id":"gothic/C/upper/v1","style":"gothic","char":"C","case":"upper",
            "bbox":{"w":1000,"h":1000,"baseline":800,"xHeight":500,"ascender":900,"descender":150},
            "nib":{"width":60,"angleDeg":35},
            "strokes":[
              {"id":"s1","order":1,"path":"M780,210 C560,210 420,310 360,480 C320,590 320,700 420,780 C510,850 620,840 730,820","durationMs":700,"delayMs":0},
              {"id":"s2","order":2,"path":"M780,210 C860,250 900,320 900,390","durationMs":420,"delayMs":60},
              {"id":"s3","order":3,"path":"M900,640 C900,720 860,790 730,820","durationMs":520,"delayMs":60}
            ]
          };
          const txt = JSON.stringify(sample, null, 2);
          jsonTA.value = txt;
          applyJson();
        }
        function play() { setPaused(false); }
        function pause() { setPaused(true); }
        function reset() { setPaused(true); setStepCount(0); /* player resets on new stepSignal=0 via rerender */ }
        function step() { setPaused(true); if (glyph) setStepCount(c => Math.min(c+1, glyph.strokes.length)); }
        function onSpeed(e) { const v = Number(e.target.value); setSpeed(Number.isFinite(v)?v:1.0); }

        file.addEventListener("change", onFile);
        apply.addEventListener("click", () => applyJson());
        loadSample.addEventListener("click", loadSampleJson);
        playBtn.addEventListener("click", play);
        pauseBtn.addEventListener("click", pause);
        resetBtn.addEventListener("click", reset);
        stepBtn.addEventListener("click", step);
        speedInp.addEventListener("change", onSpeed);

        return () => {
          file.removeEventListener("change", onFile);
          apply.removeEventListener("click", applyJson);
          loadSample.removeEventListener("click", loadSampleJson);
          playBtn.removeEventListener("click", play);
          pauseBtn.removeEventListener("click", pause);
          resetBtn.removeEventListener("click", reset);
          stepBtn.removeEventListener("click", step);
          speedInp.removeEventListener("change", onSpeed);
        };
      }, [glyph, paused]);

      return React.createElement(
        React.Fragment,
        null,
        glyph
          ? React.createElement(GlyphPlayer, { glyph, speed, paused, stepSignal: stepCount })
          : React.createElement('em', null, 'Load JSON to preview')
      );
    }

    // Mount React app into #stage
    const root = ReactDOM.createRoot(document.getElementById("stage"));
    root.render(React.createElement(AppRoot));
  </script>
</body>
</html>
